import React from 'react';
import PropTypes from 'prop-types';
import _t from 'i18n!nls/asset-admin';
import isEqual from 'lodash/isEqual';
import debounce from 'lodash/debounce';
import CdsMigrationTypography from 'bundles/authoring/common/components/cds/CdsMigrationTypography';
import { SvgButton, ToolbarTable, color } from '@coursera/coursera-ui';
import { SvgCheck, SvgBoxIn, SvgTrash, SvgUpload } from '@coursera/coursera-ui/svg';
import { Button } from '@coursera/cds-core';
import { UploadIcon } from '@coursera/cds-icons';
import { isCdsColorButtonMigrationEnabled } from 'bundles/authoring/featureFlags';

import { MED_DATE_ONLY_DISPLAY, formatDateTimeDisplay } from 'js/utils/DateTimeUtils';

import { getAssetsListByContext, setNextPageIndex } from 'bundles/asset-admin/actions/AssetAdminActions';
import TooltipWrapper from 'bundles/authoring/common/components/TooltipWrapper';
import AutoGeneratedImageAssetTableTag from 'bundles/asset-admin/components/AutoGeneratedImageAssetTableTag';
import DescriptionCompleteTag from 'bundles/asset-admin/components/DescriptionCompleteTag';
import {
  PAGE_SIZE,
  MODAL_WIDTH,
  FLAT_MID_WIDTH,
  FULL_WIDTH,
  TOOLBAR_SELECT_ALL,
  TOOLBAR_DELETE,
  TOOLBAR_SEARCH,
  TOOLBAR_FILETYPE_DROPDOWN,
  TOOLBAR_GAP,
  TOOLBAR_UPLOAD,
  NAME_FIELD,
  OPENABLE_NAME_FIELD,
  DESCRIPTION_FIELD,
  FILETYPE_FIELD,
  CREATED_AT_FIELD,
  ASSET_DOWNLOAD_FIELD,
} from 'bundles/asset-admin/constants/TableConstants';
import { getFileExtension } from 'bundles/asset-admin/utils/AssetBrowserUtils';
import { DEFAULT_CONFIDENCE_LEVEL } from 'bundles/asset-admin/utils/AutoGeneratedTagUtils';
import type { Asset } from '../types/assets';

const widthAdjustments = {
  [FULL_WIDTH]: {
    className: 'full-width',
    maxLength: 45,
    size: 900,
  },
  [FLAT_MID_WIDTH]: {
    className: 'flat-width',
    maxLength: 54,
    size: 780,
  },
  [MODAL_WIDTH]: {
    className: 'modal-width',
    maxLength: 40,
    size: 640,
  },
};

type Props = {
  courseId: string;
  currentPage: number;
  totalAssets: number;
  assetsByPage: { [page: number]: Array<Asset> };
  assetMap: { [assetId: string]: Asset & { url: { url: string; expires: number } } };
  width: string;
  pageSize: number;
  fields: Array<string>; // specify which fields in what order
  toolbar: Array<string>;
  allowedAssetTypes?: string;
  selectedAssets: Set<Asset>;
  // handlers
  onOpenAsset?: (assetId: string) => void;
  showUploadModal?: () => void;
  onSelect?: (asset: Asset) => void;
  onDeselect?: (asset: Asset) => void;
  onSearch?: (keyword?: string) => void;
  onFilter?: (assetType?: string) => void;
  handleDelete?: (assetIds: Array<string>) => void;
  allowMultiple?: boolean;
};

type State = {
  keyword?: string;
  assetType?: string;
};

/**
 * Shared component that displays a table of assets for selection, and handles filter / search.
 * State management for selection / deselection is left up to the caller.
 */
export default class AssetBrowserV2 extends React.Component<Props, State> {
  static contextTypes = {
    executeAction: PropTypes.func.isRequired,
  };

  static defaultProps: Props = {
    courseId: '',
    currentPage: 1,
    totalAssets: 1,
    assetsByPage: {},
    assetMap: {},
    onOpenAsset: (assetId: string) => assetId,
    width: FULL_WIDTH,
    pageSize: PAGE_SIZE,
    fields: [],
    toolbar: [],
    selectedAssets: new Set([]),
    allowedAssetTypes: '',
    allowMultiple: true,
  };

  state: State = {};

  handleSelection = (row: { asset: Asset }) => {
    const { onSelect } = this.props;
    if (onSelect) {
      onSelect(row.asset);
    }
  };

  handleDeselection = (row: { asset: Asset }) => {
    const { onDeselect } = this.props;
    if (onDeselect) {
      onDeselect(row.asset);
    }
  };

  handlePageChange = (page: number) => {
    const { assetsByPage, courseId, pageSize, allowedAssetTypes } = this.props;
    const { keyword, assetType } = this.state;

    if (!assetsByPage[page]) {
      const startIndex = (page - 1) * pageSize;
      this.context.executeAction(getAssetsListByContext, {
        courseId,
        startIndex,
        keyword,
        assetType: assetType || allowedAssetTypes,
        fetchUrls: true,
        pageSize,
      });
    } else {
      const nextPageIndex = page * pageSize;
      this.context.executeAction(setNextPageIndex, { nextPageIndex });
    }
  };

  handleSearch = debounce((keyword?: string) => {
    const { courseId, pageSize, allowedAssetTypes, onSearch } = this.props;
    const { assetType } = this.state;
    this.setState({ keyword });

    if (onSearch) {
      onSearch(keyword);
    }

    this.context.executeAction(getAssetsListByContext, {
      courseId,
      keyword,
      assetType: assetType || allowedAssetTypes,
      fetchUrls: true,
      pageSize,
    });
  }, 500);

  handleFilter = (assetType: string | undefined) => {
    const { courseId, pageSize, allowedAssetTypes, onFilter } = this.props;
    const { keyword } = this.state;
    this.setState({ assetType });

    if (onFilter) {
      onFilter(assetType);
    }

    this.context.executeAction(getAssetsListByContext, {
      courseId,
      assetType: assetType || allowedAssetTypes,
      keyword,
      fetchUrls: true,
      pageSize,
    });
  };

  truncateString = (words: string, maxLength: number) => `${words.substring(0, maxLength - 3)}...`;

  getRows = () => {
    const { assetsByPage, currentPage, assetMap, selectedAssets } = this.props;
    const selectedAssetArray = Array.from(selectedAssets.values());
    const assetsToDisplay = (assetsByPage[currentPage] ?? []).filter(
      (asset) => assetMap[asset.id] && asset.tags.find((tag) => tag.name === 'listed' && tag.value === 'true')
    );
    return assetsToDisplay.map((asset: Asset) => {
      const selected = selectedAssetArray.some((selectedAsset: Asset) => isEqual(asset, selectedAsset));
      return {
        asset,
        key: asset.id,
        name: { name: asset.name, selected },
        openableName: asset.name,
        fileType: getFileExtension(asset.filename),
        createdAt: asset.createdAt,
        selected,
        disabled: false,
      };
    });
  };

  nameColumn = {
    accessor: 'name',
    header: (
      <CdsMigrationTypography variant="h4bold" cuiComponentName="View">
        {_t('Name')}
      </CdsMigrationTypography>
    ),
    width: 380,
    cellRenderer: (data: { name: string; selected: boolean }, row: { asset: Asset }) => {
      const maxLength = widthAdjustments[this.props.width as keyof typeof widthAdjustments].maxLength;
      const truncName = data.name.length > maxLength;
      let cellValue: React.ReactNode = data.name;
      if (truncName) {
        cellValue = (
          <CdsMigrationTypography variant="body1" cuiComponentName="View">
            <TooltipWrapper
              message={<span className="name-tooltip">{data.name}</span>}
              tooltipId={`name-${row.asset.id}`}
            >
              {this.truncateString(data.name, maxLength)}
            </TooltipWrapper>
          </CdsMigrationTypography>
        );
      }

      return (
        <span>
          {!this.props.allowMultiple && (
            <div className={`single-select-icon ${data.selected ? 'active' : 'inactive'}`}>
              <SvgCheck suppressTitle />
            </div>
          )}
          <CdsMigrationTypography variant="body1" cuiComponentName="View">
            {cellValue}
          </CdsMigrationTypography>
        </span>
      );
    },
    comparator: (asset1: Asset, asset2: Asset) => (asset1.name.toLowerCase() > asset2.name.toLowerCase() ? 1 : -1),
    sortable: true,
  };

  openableName = {
    accessor: 'openableName',
    header: (
      <CdsMigrationTypography variant="h4bold" cuiComponentName="View" style={{ display: 'inline' }}>
        {_t('Name')}
      </CdsMigrationTypography>
    ),
    width: 300,
    cellRenderer: (name = '', row: { asset: Asset }) => {
      const maxLength = 30;
      const truncName = name.length > maxLength;
      let cellValue: React.ReactNode = (
        <CdsMigrationTypography variant="body1" cuiComponentName="View">
          {name}
        </CdsMigrationTypography>
      );
      if (truncName) {
        cellValue = (
          <CdsMigrationTypography variant="body1" cuiComponentName="View">
            <TooltipWrapper message={<span className="name-tooltip">{name}</span>} tooltipId={`name-${row.asset.id}`}>
              {this.truncateString(name, maxLength)}
            </TooltipWrapper>
          </CdsMigrationTypography>
        );
      }

      return (
        <button
          type="button"
          onClick={() => this.props.onOpenAsset && this.props.onOpenAsset(row.asset.id)}
          className="asset-name nostyle"
        >
          {cellValue}
        </button>
      );
    },
    comparator: (name1: string, name2: string) => (name1.toLowerCase() > name2.toLowerCase() ? 1 : -1),
    sortable: true,
  };

  getAvailableDescription = (asset: Asset) => {
    const description = asset.tags.find((tag) => tag.name === 'description')?.value;
    const longDescription = asset.tags.find((tag) => tag.name === 'longDescription')?.value;
    return description || longDescription || '';
  };

  descriptionColumn = {
    accessor: 'asset',
    header: (
      <CdsMigrationTypography variant="h4bold" cuiComponentName="View" style={{ display: 'inline' }}>
        {_t('Accessibility')}
      </CdsMigrationTypography>
    ),
    width: 230,
    cellRenderer: (asset: Asset) => {
      const maxLength = 120;
      const availableDescription = this.getAvailableDescription(asset);
      const shownDescription =
        availableDescription.length > maxLength
          ? this.truncateString(availableDescription, maxLength)
          : availableDescription;

      if (shownDescription) {
        if (asset.isDescriptionAutoGenerated) {
          return (
            <AutoGeneratedImageAssetTableTag
              confidenceLevel={asset.autoGenDescriptionConfidenceLevel}
              description={shownDescription}
            />
          );
        } else {
          return <DescriptionCompleteTag description={shownDescription} />;
        }
      } else {
        return null;
      }
    },
    /**
     * Sorting assets based on accessibility. Sorting high to low has the following priority: manually-added descriptions,
     * auto-generated descriptions in order of confidence, assets with the possibility of a description tag (currently only
     * image assets), and then all other assets.
     */
    comparator: (asset1: Asset, asset2: Asset) => {
      if (asset1.isDescriptionAutoGenerated === false && this.getAvailableDescription(asset1)) {
        return -1;
      } else if (asset2.isDescriptionAutoGenerated === false && this.getAvailableDescription(asset2)) {
        return 1;
      }
      const asset1ConfidenceLevel = asset1.autoGenDescriptionConfidenceLevel ?? DEFAULT_CONFIDENCE_LEVEL;
      const asset2ConfidenceLevel = asset2.autoGenDescriptionConfidenceLevel ?? DEFAULT_CONFIDENCE_LEVEL;

      if (
        asset1.isDescriptionAutoGenerated &&
        (!asset2.isDescriptionAutoGenerated || asset1ConfidenceLevel >= asset2ConfidenceLevel)
      ) {
        return -1;
      } else if (
        asset2.isDescriptionAutoGenerated &&
        (!asset1.isDescriptionAutoGenerated || asset2ConfidenceLevel > asset1ConfidenceLevel)
      ) {
        return 1;
      }

      if (asset1.typeName === 'image') {
        return -1;
      } else if (asset2.typeName === 'image') {
        return 1;
      }

      return -1;
    },
    sortable: true,
  };

  fileTypeColumn = {
    accessor: 'fileType',
    header: (
      <CdsMigrationTypography variant="h4bold" cuiComponentName="View" style={{ display: 'inline' }}>
        {_t('Extension')}
      </CdsMigrationTypography>
    ),
    width: 130,
    cellRenderer: (fileType: string, row: { asset: Asset }) => {
      const maxLength = 10;
      const truncName = fileType.length > maxLength;
      let cellValue: React.ReactNode = (
        <CdsMigrationTypography variant="body1" cuiComponentName="View">
          {fileType}
        </CdsMigrationTypography>
      );
      if (truncName) {
        cellValue = (
          <CdsMigrationTypography variant="body1" cuiComponentName="View">
            <TooltipWrapper
              tooltipId={`filetype-${row.asset.id}`}
              message={<span className="name-tooltip">{fileType}</span>}
            >
              {this.truncateString(fileType, maxLength)}
            </TooltipWrapper>
          </CdsMigrationTypography>
        );
      }

      return cellValue;
    },
    sortable: true,
  };

  createdAtColumn = {
    accessor: 'createdAt',
    header: (
      <CdsMigrationTypography variant="h4bold" cuiComponentName="View" style={{ display: 'inline' }}>
        {_t('Last Updated')}
      </CdsMigrationTypography>
    ),
    width: 140,
    cellRenderer: (createdAt: number) =>
      createdAt !== undefined ? (
        <CdsMigrationTypography variant="body1" cuiComponentName="View">
          {formatDateTimeDisplay(createdAt, MED_DATE_ONLY_DISPLAY)}
        </CdsMigrationTypography>
      ) : null,
    sortable: true,
  };

  assetDownloadColumn = {
    accessor: 'asset',
    width: 75,
    cellRenderer: (asset: Asset) => {
      const { assetMap, handleDelete } = this.props;
      const downloadLink = assetMap[asset.id]?.url.url;
      return (
        asset && (
          <span className="action-btns">
            <TooltipWrapper message={downloadLink ? _t('Download') : _t('Download Unavailable')}>
              <a download={asset.name} href={downloadLink} target="_blank" rel="noopener noreferrer">
                <SvgBoxIn size={16} suppressTitle />
              </a>
            </TooltipWrapper>
            <TooltipWrapper message={_t('Delete')}>
              <SvgButton
                rootClassName="asset-delete-btn"
                onClick={() => handleDelete && handleDelete([asset.id])}
                type="icon"
                svgElement={<SvgTrash size={16} suppressTitle />}
                size="zero"
              />
            </TooltipWrapper>
          </span>
        )
      );
    },
  };

  getColumns = () => {
    const { fields } = this.props;

    const fieldMap = {
      [NAME_FIELD]: this.nameColumn,
      [OPENABLE_NAME_FIELD]: this.openableName,
      [DESCRIPTION_FIELD]: this.descriptionColumn,
      [FILETYPE_FIELD]: this.fileTypeColumn,
      [CREATED_AT_FIELD]: this.createdAtColumn,
      [ASSET_DOWNLOAD_FIELD]: this.assetDownloadColumn,
    };
    return fields.map((field) => fieldMap[field as keyof typeof fieldMap]);
  };

  getToolbar = () => {
    const { allowedAssetTypes, handleDelete, showUploadModal, toolbar } = this.props;

    const selectAll = { type: 'select-all' };
    const deleteAction = {
      type: 'selection-action',
      svgElement: <SvgTrash hoverColor={color.danger} title={_t('Delete')} />,
      isEnabled: (selection: Array<{ asset: Asset }>) => selection.length > 0,
      onClick: (e: Event, selection: Array<{ asset: Asset }>) => {
        const assetIds = selection.map((row: { asset: Asset }) => row.asset.id);
        if (handleDelete) {
          handleDelete(assetIds);
        }
      },
    };
    const search = {
      type: 'search',
      placeholder: _t('Search...'),
      matches: () => true,
      onUpdate: this.handleSearch,
    };
    const fileTypeDropdown = {
      type: 'dropdown',
      placeholder: _t('File Type'),
      options: [
        { value: 'image', label: _t('Image') },
        { value: 'video', label: _t('Video') },
        { value: 'pdf', label: _t('PDF') },
        { value: 'audio', label: _t('Audio') },
        { value: 'generic', label: _t('Other') }, // this is for any other file format (eg no file extension available on file)
      ].filter((assetType) => (allowedAssetTypes ? assetType.value === allowedAssetTypes : assetType)),
      matches: () => true,
      onUpdate: this.handleFilter,
    };
    const gap = {
      type: 'gap',
      renderer: () => <div className="spacer" />,
    };

    const getUploadButton = () => {
      if (isCdsColorButtonMigrationEnabled()) {
        return (
          <Button
            variant="ghost"
            size="medium"
            onClick={showUploadModal}
            icon={<UploadIcon size="medium" />}
            iconPosition="before"
            className="upload-button"
          >
            {_t('Upload Assets')}
          </Button>
        );
      }
      return (
        <SvgButton
          rootClassName="upload-button"
          type="link"
          size="sm"
          svgElement={<SvgUpload color={color.primary} />}
          label={_t('Upload Assets')}
          onClick={showUploadModal}
        />
      );
    };

    const uploadAction = {
      type: 'selection-action',
      renderer: () => getUploadButton(),
    };
    const toolbarMapping = {
      [TOOLBAR_SELECT_ALL]: selectAll,
      [TOOLBAR_DELETE]: deleteAction,
      [TOOLBAR_SEARCH]: search,
      [TOOLBAR_FILETYPE_DROPDOWN]: fileTypeDropdown,
      [TOOLBAR_GAP]: gap,
      [TOOLBAR_UPLOAD]: uploadAction,
    };
    return toolbar.map((toolbarOption) => toolbarMapping[toolbarOption as keyof typeof toolbarMapping]);
  };

  render() {
    const { currentPage, totalAssets, pageSize, width } = this.props;

    return (
      <ToolbarTable
        enableSelection
        enablePagination
        onPageChange={this.handlePageChange}
        currentPage={currentPage}
        maxPages={10}
        pageCount={Math.ceil(totalAssets / pageSize)}
        onSelect={this.handleSelection}
        onDeselect={this.handleDeselection}
        toolbar={this.getToolbar()}
        rows={this.getRows()}
        columns={this.getColumns()}
        width={widthAdjustments[width as keyof typeof widthAdjustments]?.size}
      />
    );
  }
}
