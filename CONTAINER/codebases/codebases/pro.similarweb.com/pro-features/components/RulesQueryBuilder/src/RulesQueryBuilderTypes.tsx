import { ISegmentUrl } from "pages/segments/wizard/SegmentRulesStep/SegmentUrlList/SegmentUrlListTypes";
import { IWordsFilterConfig } from "services/segments/segmentsWizardServiceTypes";
import { ISite } from "components/Workspace/Wizard/src/types";

/**
 * Defines the type of rule: either an includer or excluder rule
 * (include: include onlu provided strings,
 * exclude: include everything besides provided strings)
 */
export enum RuleTypes {
    include,
    exclude,
}

/**
 * The state of the rules:
 * Init = New (empty) rule
 * Edit = A rule in edit mode (when choosing a new word for the rule)
 * Complete = When at least one word was provided for the rule
 */
export enum RuleModes {
    init,
    edit,
    complete,
}

/**
 * Represents a single rule generated by the RulesQueryBuilder
 */
export interface IRule {
    type: RuleTypes;
    words: string[];
    exact: string[];
    folders: string[];
    exactURLS: string[];
}

/**
 * Represents word predictions - these are the words that can be picked by
 * the user for his rules.
 */
export interface IWordPredictions {
    Data: string[];
    TotalCount: number;
    Header: {
        MainSite: string;
    };
}

/**
 * Represents word predictions - these are the words that can be picked by
 * the user for his rules.
 */
export interface IFolderPredictions extends IWordPredictions {}

/**
 * URL Previews - the popular pages after being filtered by the provided
 * user rules.
 */
export interface IPopularSegments {
    Data: Array<{
        Page: {
            Highlights: [
                {
                    word: string;
                    startIndex: number;
                    endIndex: number;
                },
            ];
            URL: string;
        };
        Share: number;
    }>;
    TotalCount: number;
    Header: {
        MainSite: string;
    };
}

export const RuleTypesDropdown = [
    {
        id: RuleTypes.include,
        text: "segmentsWizard.ruleTypes.include",
    },
    {
        id: RuleTypes.exclude,
        text: "segmentsWizard.ruleTypes.exclude",
    },
];

export interface IRulesQueryBuilderProps {
    /**
     * Sets the given rules on the redux store
     */
    updateSegmentRules: (rules: IRule[]) => void;

    /**
     * Updates the word predictions on redux store
     */
    updateWordPredictions: (shouldFetchWordsOnly: boolean, ruleIndex?: number) => Promise<void>;

    /**
     * sets the show wizard tips flag value on the redux store
     */
    updateShowWizardTips: (showWizardTips: boolean) => void;

    /**
     * Retreives a list of URLs based on the given set of rules
     */
    getSegmentUrls: (rules: IRule[]) => Promise<ISegmentUrl[]>;

    /**
     * Retrieves word predictions data based on the given set of rules
     */
    getWordPredictions: (
        rules: IRule[],
        shouldFetchWordsOnly?: boolean,
        overrideWordsFilterConfig?: IWordsFilterConfig,
    ) => Promise<IWordPredictions>;

    /**
     * return a boolean value is urls exist for set of rules
     */
    hasExistingUrlsCompundStringNoRobots: (rules: IRule[]) => Promise<any>;

    /**
     * Indicates if the word predictions are currently being
     * fetched from the API.
     * returned from the segmentWizard redux store.
     */
    wordPredictionsLoading: boolean;

    /**
     * Indicates if the segment preview data is currently
     * being processed / loaded.
     * returned from the segmentWizard redux store.
     */
    segmentsPreviewLoading: boolean;

    /**
     * The segments wizard folders predictions.
     * returned from the segmentWizard redux store.
     */

    folderPredictions: any;

    /**
     * The wizard's segment rules.
     * returned from the segmentWizard redux store.
     */
    segmentRules: IRule[];

    selectedSite: ISite;
    hideUrlsPreview: boolean;
}
