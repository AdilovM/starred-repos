import HttpStatus from 'constants/http-status';
import LessonHelper from 'helpers/lesson-helper';
import NodeHelper from 'helpers/node-helper';
import ProjectHelper from 'helpers/project-helper';

function _createPropertyCollectionKey(property) {
    return `_${property}_keys`;
}

function _createPropertyKey(property) {
    return `_${property}_key`;
}

const ReducerHelper = {
    /* Returns a new object with the specified property removed and mapped to a list of keys.
       It's expected that `obj[property]` be a collection */
    mapPropertyCollectionToKeys(obj, property) {
        var list = obj[property];

        obj = _.omit(obj, property);
        obj[_createPropertyCollectionKey(property)] = _.map(list, 'key');

        return obj;
    },

    /* Returns a new object with the specified property removed and mapped to a key.
       It's expected that `obj[property]` be a node with a key */
    mapPropertiesToKeys(obj, ...properties) {
        return _.reduce(
            obj,
            (updatedObj, value, key) => {
                if (_.includes(properties, key)) {
                    return {
                        ...updatedObj,
                        [_createPropertyKey(key)]: _.get(value, 'key'),
                    };
                }
                return { ...updatedObj,
                    [key]: value
                };
            }, {}
        );
    },

    /* Gets the list of keys generated by `mapPropertyCollectionToKeys` */
    getMappedPropertyCollectionKeys(obj, property) {
        return obj[_createPropertyCollectionKey(property)];
    },

    /* Gets the key generated by `mapPropertiesToKeys` */
    getMappedPropertyKey(obj, property) {
        return obj[_createPropertyKey(property)];
    },

    /* Returns true if this is a key for a mapped property collection keys as generated by
       _mapPropertyCollectionToKeys, ex: '_lessons_keys' */
    isPropertyCollectionKey(key) {
        return /^_\w+_keys$/.test(key);
    },

    /* This is the merge we use to merge updated nodes from graphQL response. The only difference with
       lodash merge is that this will overwrite instead of concat arrays, which is the behavior we desire
       when it comes to removing children keys */
    merge(...objects) {
        return _.mergeWith(...objects, function(objValue, otherValue) {
            if (_.isArray(otherValue)) {
                return otherValue;
            }
        });
    },

    getPartsForNanodegree(nanodegree) {
        return nanodegree.parts;
    },

    getLabsForNanodegree(nanodegree) {
        const lessons = ReducerHelper.getLessonsForNanodegree(nanodegree);

        return _.map(LessonHelper.getLabsFromLessons(lessons), (lab) => ({
            ...lab,
            due_at: ProjectHelper.getProjectDueAt(nanodegree, lab.progress_key),
        }));
    },

    getLabsForPartAsCourse(partAsCourse) {
        const lessons = ReducerHelper.getLessonsForPart(partAsCourse);

        return _.map(LessonHelper.getLabsFromLessons(lessons), (lab) => ({
            ...lab,
            due_at: undefined, //TODO: SXP-501 part.project_deadlines is not yet supported
        }));
    },

    getProjectsForNanodegree(nanodegree) {
        const lessons = ReducerHelper.getLessonsForNanodegree(nanodegree);

        return _.map(LessonHelper.getProjectsFromLessons(lessons), (project) => ({
            ...project,
            due_at: ProjectHelper.getProjectDueAt(nanodegree, project.progress_key),
        }));
    },

    getModulesForNanodegree(nanodegree) {
        var parts = ReducerHelper.getPartsForNanodegree(nanodegree);

        return _.flatten(_.map(parts, 'modules'));
    },

    getLessonsForNanodegree(nanodegree) {
        var modules = ReducerHelper.getModulesForNanodegree(nanodegree);

        return _.flatten(_.map(modules, 'lessons'));
    },

    getConceptsForNanodegree(nanodegree) {
        var lessons = ReducerHelper.getLessonsForNanodegree(nanodegree);

        return _.flatten(_.map(lessons, 'concepts'));
    },

    getModulesForPart(part) {
        return part.modules;
    },

    getLessonsForPart(part) {
        var modules = ReducerHelper.getModulesForPart(part);

        return _.flatten(_.map(modules, 'lessons'));
    },

    getConceptsForPart(part) {
        var lessons = ReducerHelper.getLessonsForPart(part);

        return _.flatten(_.map(lessons, 'concepts'));
    },

    getLessonsForCourse(course) {
        return course.lessons;
    },

    getProjectForCourse(course) {
        return course.project;
    },

    getProjectsFromCourseLessons(course) {
        const lessons = ReducerHelper.getLessonsForCourse(course);
        return LessonHelper.getProjectsFromLessons(lessons);
    },

    getProjectsFromPartLessons(part) {
        const lessons = ReducerHelper.getLessonsForPart(part);
        return LessonHelper.getProjectsFromLessons(lessons);
    },

    getConceptsForCourse(course) {
        var lessons = ReducerHelper.getLessonsForCourse(course);

        return _.flatten(_.map(lessons, 'concepts'));
    },

    getAggregatedStateForNanodegree(nanodegree) {
        return nanodegree.aggregated_state;
    },

    getPartAggregatedStatesForNanodegree(nanodegree) {
        return ReducerHelper.getAggregatedStateForNanodegree(nanodegree)
            .part_aggregated_states;
    },

    getModuleAggregatedStatesForNanodegree(nanodegree) {
        var partAggregatedStates = ReducerHelper.getPartAggregatedStatesForNanodegree(
            nanodegree
        );

        return _.chain(partAggregatedStates)
            .map('module_aggregated_states')
            .flatten()
            .compact()
            .value();
    },

    getLessonAggregatedStatesForNanodegree(nanodegree) {
        var moduleAggregatedStates = ReducerHelper.getModuleAggregatedStatesForNanodegree(
            nanodegree
        );

        return _.chain(moduleAggregatedStates)
            .map('lesson_aggregated_states')
            .flatten()
            .compact()
            .value();
    },

    getAggregatedStateForCourse(course) {
        return course.aggregated_state;
    },

    getLessonAggregatedStatesForCourse(course) {
        return ReducerHelper.getAggregatedStateForCourse(course)
            .lesson_aggregated_states;
    },

    //SXP-124: used in lesson reducer, mocked in spec
    getLessonAggregatedStatesForPart() {
        return {};
    },

    getConceptsForLesson(lesson) {
        return lesson.concepts;
    },

    getAtomsForLesson(lesson) {
        var concepts = ReducerHelper.getConceptsForLesson(lesson);

        return _.flatten(_.map(concepts, 'atoms'));
    },

    updateAggregatedState(node, lastViewedChildKey, lastViewedAt, increment) {
        const aggState = {
            ...node._aggregated_state,
            last_viewed_child_key: lastViewedChildKey,
        };

        if (increment) {
            const completedCount = NodeHelper.getAggregatedStateValue(
                node,
                'completed_count'
            );
            const conceptCount = NodeHelper.getAggregatedStateValue(
                node,
                'concept_count'
            );
            const nextCompleted = Math.min(conceptCount, completedCount + 1);

            aggState.completed_count = nextCompleted;
            aggState.completion_amount = nextCompleted / conceptCount;

            if (nextCompleted === conceptCount) {
                aggState.completed_at = lastViewedAt;
            }
        }

        return { ...node,
            _aggregated_state: aggState
        };
    },

    mergeUserState(state, userState) {
        if (state && userState && state[userState.node_key]) {
            var node = state[userState.node_key];
            return { ...state,
                [node.key]: { ...node,
                    user_state: userState
                }
            };
        }
        return state;
    },

    mergeAggregatedStates(state, aggregatedStates) {
        if (!aggregatedStates || aggregatedStates.length === 0) {
            return state;
        }

        var state = _.clone(state);
        _.each(aggregatedStates, (aggregatedState) => {
            ReducerHelper._mergeAggregatedState(state, aggregatedState);
        });

        return state;
    },

    _mergeAggregatedState(state, aggregatedState) {
        var node = state[aggregatedState.node_key];
        if (!node) {
            node = state[aggregatedState.node_key] = {};
        }

        node._aggregated_state = ReducerHelper.merge({},
            node._aggregated_state,
            aggregatedState
        );
    },

    getOrderForChinaSubscriptionPayments(state, order) {
        return Object.assign({}, state, {
            order: {
                ndKey: order.ndKey,
                id: order.id,
                code_url: order.code_url,
                message: order.message,
                alipay_url: order.alipay_url,
                fql_url: order.fql_url,
                billing_info: order.billing_info,
                status: order.status || 'init',
            },
        });
    },

    getRechargeForChinaSubscription(state, order) {
        return Object.assign({}, state, {
            order: {
                ndKey: state.order.ndKey,
                id: state.order.id,
                code_url: state.order.code_url,
                alipay_url: state.order.alipay_url,
                fql_url: state.order.fql_url,
                billin_info: state.order.billing_info,
                status: order.status,
            },
        });
    },

    getAmountOffForChinaSubscription(state, response) {
        if (response.status === HttpStatus.Forbidden) {
            return Object.assign({}, state, {
                coupon: {
                    status: response.responseJSON.status,
                    message: response.responseJSON.message,
                },
            });
        }

        return Object.assign({}, state, {
            coupon: {
                status: response.status,
                amountOff: response.amountOff,
            },
            order: {
                code_url: null,
                alipay_url: null,
            },
        });
    },
};

export default ReducerHelper;